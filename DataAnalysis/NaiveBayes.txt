〇CounterVectorizer()：テキストデータを「バギング・オブ・ワーズ」として数値ベクトルに変換するためのツール。具体的には、テキストのコーパス全体に基づいて各単語の出現回数を数え上げ、それをベクトルとして表現します。
print(X)の結果で示される(0, 4) 1のような出力は、スパース行列の表現方法です。具体的には以下のように解釈します：

(0, 4) 1: これは、最初の文（インデックス0の文）において、4番目の単語が1回出現していることを示しています。
vectorizer.get_feature_names_out()を使用して列番号とその列が何の単語を示しているのかを確認することができます。

実際のデータと結果を組み合わせて解釈すると：

(0, 4) 1: 最初の文 "最新のiPhoneを手に入れよう！" において、vectorizer.get_feature_names_out()によると、4番目の単語は"最新の"で、この単語が1回出現していることを示しています。
(1, 3) 1: 2番目の文 "昼食に何を食べるか考えています。" で、3番目の単語 "昼食に" が1回出現。
(2, 1) 1: 3番目の文 "今週末、映画を観に行こうと思っています。" で、1番目の単語 "今週末" が1回出現。
(2, 2) 1: 同じ3番目の文で、2番目の単語 "映画を" が1回出現。
(3, 0) 1: 4番目の文 "お金を稼ぐ方法を教えます！" で、0番目の単語 "お金を" が1回出現。
以上のように、このスパース行列の表現は、どの文（行）にどの単語（列）が何回出現しているかを示しています。スパース行列は、ほとんどの要素が0である大きな行列を効率的に表現するための形式です。この例では、各文に出現する単語の数が非常に少ないため、スパース行列として表現されています。

☆CountVectorizerによって生成される辞書内の単語のインデックスは、デフォルトの設定では単語のアルファベット順（辞書順）を基準にして割り振られます。

①本ソース内での割り振りと、実際に生成された辞書の出力：
{'最新のiphoneを手に入れよう': 4, '昼食に何を食べるか考えています': 3, '今週末': 1, '映画を観に行こうと思っています': 2, 'お金を稼ぐ方法を教えます': 0}

比較
②列番号の出力(for i, word in enumerate(feature_names):
    print(f"列番号 {i}: {word}")の結果)：
列番号 0: お金を稼ぐ方法を教えます
列番号 1: 今週末
列番号 2: 映画を観に行こうと思っています
列番号 3: 昼食に何を食べるか考えています
列番号 4: 最新のiphoneを手に入れよう

上の①②より、
# 辞書の単語とそのインデックスを表示
print(vectorizer.vocabulary_)の出力結果を考える：
  (0, 4)        1
  (1, 3)        1
  (2, 1)        1
  (2, 2)        1
  (3, 0)        1
→各行について、出力の形式(a, b) cは以下の意味を持つ:
a: ドキュメント（メッセージ）のインデックス
b: 単語のインデックス（辞書内の位置）
c: その単語の出現回数
  (0, 4)        1  -> 最初のメッセージに「最新のiphoneを手に入れよう」という単語が1回出現
  (1, 3)        1  -> 2番目のメッセージに「昼食に何を食べるか考えています」という単語が1回出現
  (2, 1)        1  -> 3番目のメッセージに「今週末」という単語が1回出現
  (2, 2)        1  -> 3番目のメッセージに「映画を観に行こうと思っています」という単語が1回出現
  (3, 0)        1  -> 4番目のメッセージに「お金を稼ぐ方法を教えます」という単語が1回出現
  →☆実際に、NaiveBayes.py内のサンプルデータの各インデックスのデータと辞書のデータおよびそのインデックスを比較するとわかりやすい

☆get_feature_names_out()メソッドとvocabulary_属性の違い：
get_feature_names_out():
ボキャブラリー内の単語をソートした順（通常は文字コード順）に返す
vocabulary_:
何を返すか: ボキャブラリー内の各単語と、その単語が持つインデックスをソートすることなく返す

→つまり、vocabulary_を使用すると、特定の単語がベクトルのどの位置に対応するかを知ることができ、get_feature_names_out()を使用すると、ベクトルの各位置がどの単語に対応するかを知ることができる

